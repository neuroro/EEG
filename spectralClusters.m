function ...
Stats = spectralClusters( pThreshold, frequencyBand, timeLimits, ...
                          nPermutations, downsampling,           ...
                          conditionA, conditionB,                ...
                          localSpectraA, localSpectraB           )
%
% •.° Differential Oscillatory Clusters °.•
% _________________________________________________________________________
%
% Statistical hypothesis testing of oscillatory differences in neural
% event-related spectral metrics using Monte Carlo permutation tests with
% the maximum sum of cluster dependent samples t-statistics as the test
% statistic of the permutation tests
%
% Localised event-related spectral data is collated by eegLocalSpectra.m
% from time-frequency decompositions generated by eegTimeFrequency.m or
% equivalent (King, 2023) available at https://github.com/neuroro/EEG/
%
% • Usage •
% ------------------------------------------------------------------------- 
% Set the Current Folder to the location of the localised event-related 
% spectra files TimeFrequency<Cluster>.mat
%
% Specify the conditions and local spectra files to compare as input
% arguments of the function or edit the Configuration section of the
% function code (found below this help text)
% 
% >> spectralClusters( pThreshold, frequencyBand, timeLimits, ...
%                      nPermutations, downsampling,           ...
%                      conditionA, conditionB,                ...
%                      localSpectraA, localSpectraB           )
% 
% For example:
% >> spectralClusters
% >> Stats = spectralClusters( 0.025, 'theta+', [0 1000], 1e5, 250 );
% >> Stats = spectralClusters( 0.05, [], [], 1e5, 'none' );
% >> Stats = spectralClusters( 0.05, [], [], 1e5, 250, 'Active', 'Control' );
%
% .. . .  .   .     .        .             .                     .                                  .
%
% •••( Function Inputs )
%
%   pThreshold:    Threshold as a p-value from which the equivalent
%                   |t|-value at the degrees of freedom of the data is
%                   used to form clusters of spectral differences
%                  (optional input: default 0.025)
%
%   frequencyBand: Frequency band (named) or frequency range (limits)
%                   within which to test differences
%                    'Delta'        1 to <4 Hz
%                    'Theta'        4 to <8 Hz
%                    'Theta+'     2.5 to 8.5 Hz
%                    'Theta++'      2 to 10 Hz
%                    'Alpha'        8 to <13 Hz
%                    'Beta'        13 to 30 Hz
%                    'Gamma'      >30 to 80 Hz
%                    'Low Gamma'  >30 to 50 Hz
%                    'High Gamma' >50 to 80 Hz
%                    [f1 f2]       f1 to f2 Hz frequency range
%                    '' or []      all frequencies
%                   (optional input: default all frequencies)
%
%   timeLimits:    Time limits (in ms) to test differences within as a
%                   scalar of the maximum time for stimulus-related spectra
%                    with other time limits dervied in proportion to it; a
%                   [t1 t2] vector of stimulus-related time limits with
%                    other time limits dervied in proportion to t2; a
%                   w x t matrix of time limits (t) for each event-related
%                    window (w), semicolon-separated in alphabetical order,
%                    for example [t1Stim t2Stim; t1Resp t2Resp]; or 0 or []
%                    for the whole window
%                   (optional input: default 0 - 1000 ms after the stimulus
%                    and -500 - +500 ms around the response and around
%                    initiation if present)
%
%   nPermutations:  Number of Monte Carlo permutations of the data to
%                    compute to estimate the permutation p-value
%                   (optional input, default 1e4, but 1e5 or more is
%                    recommended for stable covergence to the true
%                    permutation p-value)
%
%   downsampling:   Sampling rate (in Hz) to downsample the data to using
%                    pop_resample from EEGLAB for anti-aliasing, which may
%                    be used to speed up the computation time, in case 2-D
%                    cluster permutation testing takes too long, or 'none'
%                   (optional input: default 250 Hz)
%
%   conditionA:     1st condition to compare as 'ConditionName' or as 
%                    { 'Condition1' 'Condition2' ... } for the average of
%                    multiple conditions
%                   (optional input, otherwise specify in configuration)
%
%   conditionB:     2nd condition to compare as 'ConditionName' or as 
%                    { 'Condition1' 'Condition2' ... } for the average of
%                    multiple conditions
%                   (optional input, otherwise specify in configuration)
%
%   localSpectraA:  1st file name of EEG time-frequency data to compare
%                   (optional input, otherwise specify in configuration)
%
%   localSpectraB:  2nd file name of EEG time-frequency data to compare
%                   (optional input, otherwise specify in configuration)
%
%   To compare 2 conditions or 2 condition averages within the same local
%   spectra .mat file:
%    Specify conditionA and conditionB as their respective 'ConditionName'
%     or as their respective { 'Condition1' 'Condition2' ... } for averages
%     of multiple conditions
%    Specify localSpectraA (localSpectraB defaults to the same file)
%
%   To compare 2 groups in separate local spectra .mat files, within the 
%   same condition or condition average:
%    Specify conditionA and conditionB as the same 'ConditionName' or the
%     same { 'Condition1' 'Condition2' ... } for an average of multiple
%     conditions
%    Specify localSpectraA and localSpectraB as their respective local 
%     spectra .mat files
%
%   To compare 2 conditions or 2 condition averages within separate local
%   spectra .mat files:
%    Specify conditionA and conditionB as their respective 'ConditionName'
%     or as their respective { 'ConditionName1' 'ConditionName2' ... } for
%     averages of multiple conditions
%    Specify localSpectraA and localSpectraB as their respective local 
%     spectra .mat files
%
% .. . .  .   .     .        .             .                     .                                  .
%
% [ Function Outputs ] =
%
%   Cluster permutation test statistics and descriptive statistics of
%    event-related spectra distributions and plots of grand average
%    spectra, difference spectra, masked t-maps, and the distributions
%    across people of spectral dispersion and spectral clusters
%
% !!! Requires !!!
%
%   plotTimeFrequency.m by Rohan King (2023) available at
%    https://github.com/neuroro/EEG/plotTimeFrequency.m
%
%   descriptiveStatsitics.m by Rohan King (2023) available at
%    https://github.com/neuroro/EEG/descriptiveStatsitics.m
%
%   montecluster.m, distanceFunction.m, & grow.m available from the author
%
%   EEGLAB for downsampling with anti-aliasing
%
%   raincloud_plot_k.m by Allen et al. (2021) modified by Rohan King (2024)
%    available from this author or raincloud_plot.m by Allen et al. (2021)
%    available at https://github.com/RainCloudPlots/RainCloudPlots/blob/master/tutorial_matlab/raincloud_plot.m
%
% • Author •
% -------------------------------------------------------------------------
% Rohan O. C. King, 2023
%
% GitHub @neuroro
%
% Copyright 2023 Rohan King
%
% This program is free software: you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation, either version 3 of the License, or (at your
% option) any later version.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
% Public License for more details (https://www.gnu.org/licenses/).
%
% Please cite this code if you use it
%
% King, R. (2023). spectralClusters [MATLAB code]. GitHub. 
%  https://github.com/neuroro/EEG/spectralClusters.m


% • TO IMPLEMENT IN FUTURE •
% -------------------------------------------------------------------------
% Variable input arguments
% Export data for statistical analysis in other software


%% Configuration (optional)
% -------------------------------------------------------------------------

% To compare 2 conditions or 2 condition averages within the same local
% spectra .mat file:
%  Specify condition1 and condition2 as their respective 'ConditionName' or
%   as { 'Name1' 'Name2' ... } for the average of multiple conditions
%  Specify localSpectra1 and localSpectra2 as the same local spectra file

% To compare 2 groups in separate local spectra .mat files, within the same
% condition or condition average:
%  Specify condition1 and condition2 as the same 'ConditionName' or
%   { 'Name1' 'Name2' ... } for the average of multiple conditions
%  Specify localSpectra1 and localSpectra2 as their respective local 
%   spectra .mat files

% To compare 2 conditions or 2 condition averages within separate local
% spectra .mat files:
%  Specify condition1 and condition2 as their respective 'ConditionName' or
%   as { 'Name1' 'Name2' ... } for the average of multiple conditions
%  Specify localSpectra1 and localSpectra2 as their respective local 
%   spectra .mat files

% Condition labels
% as 'ConditionName' or { 'Name1' 'Name2' ... } for the average of multiple
condition1 = 'ConditionName1';
condition2 = 'ConditionName2';

% Local spectra file names
% with or without the .mat file extension
localSpectra1 = 'TimeFrequencyCluster1.mat';
localSpectra2 = 'TimeFrequencyCluster2.mat';


%% Startup
% -------------------------------------------------------------------------

% Initialise EEGLAB if needed
if ~isempty( downsampling ) && isnumeric( downsampling ) && ...
   downsampling > 0 && exist( 'eeglab', 'file' )
    eegStartup
end

% Reset the Command Window without clearing
home

% Introduction
disp( ' ' )
disp( '•.° Differential Oscillatory Clusters °.•' )
disp( '_________________________________________________________________________' )
disp( ' ' )
disp( 'Statistical hypothesis testing of oscillatory differences in neural'     )
disp( 'event-related spectral metrics using Monte Carlo permutation tests with' )
disp( 'the maximum cluster sum of dependent samples t-statistics as the test'   )
disp( 'statistic of the permutation tests'                                      )
disp( ' ' )
disp( 'Localised event-related spectral data is collated by eegLocalSpectra.m' )
disp( 'from time-frequency decompositions generated by eegTimeFrequency.m or'  )
disp( 'equivalent (King, 2023) available at https://github.com/neuroro/EEG/'   )
disp( 'Test oscillatory differences in neural event-related spectra'           )
disp( ' ' )


%% Inputs
% -------------------------------------------------------------------------

% Conditions
if exist( 'conditionA', 'var' )
    condition1 = conditionA;
end
if exist( 'conditionB', 'var' )
    condition2 = conditionB;
end
if iscell( condition1 )
    condition1Name = char( join( condition1 ) );
else
    condition1Name = condition1;
end
if iscell( condition2 )
    condition2Name = char( join( condition2 ) );
else
    condition2Name = condition2;
end

% Local spectra .mat files
if exist( 'localSpectraA', 'var' )
    localSpectra1 = localSpectraA;
end
if exist( 'localSpectraB', 'var' )
    localSpectra2 = localSpectraB;
end
if exist( 'localSpectraA', 'var' ) && ~exist( 'localSpectraB', 'var' )
    localSpectra2 = localSpectra1;
end
if ~contains( localSpectra1, '.mat' )
    localSpectra1 = [ localSpectra1 '.mat' ];
end
if ~contains( localSpectra2, '.mat' )
    localSpectra2 = [ localSpectra2 '.mat' ];
end
spectra1Name = extractBefore( localSpectra1, '.mat' );
spectra2Name = extractBefore( localSpectra2, '.mat' );

% Comparison
if matches( condition1Name, condition2Name )
    comparison1 = spectra1Name;
    comparison2 = spectra2Name;
    comparison3 = [ 'for ' condition1Name ];
elseif matches( spectra1Name, spectra2Name )
    comparison1 = condition1Name;
    comparison2 = condition2Name;
    comparison3 = [ 'for ' spectra1Name ];
else
    comparison1 = [ condition1Name ' ' spectra1Name ];
    comparison2 = [ condition2Name ' ' spectra2Name ];
    comparison3 = '';
end

% Number of permutations
if ~exist( 'nPermutations', 'var' )
    nPermutations = 1e4;
end

% Cluster p-value threshold
if ~exist( 'pThreshold', 'var' )
    pThreshold = 0.025;
end

% Frequency band
if ~exist( 'frequencyBand', 'var' )
    frequencyBand = [];
end
if isstring( frequencyBand )
    frequencyBand = char( frequencyBand );
end

% Time limit
if ~exist( 'timeLimits', 'var' )
    timeLimits = 1000;
end

% Downsampling to speed up computation
if ~exist( 'downsampling', 'var' )
    downsampling = 250;
end


%% Decomposition properties
% -------------------------------------------------------------------------

clusterRunTime( 'Loading' )

% Local spectra mat file paths
spectraPath1 = which( localSpectra1 );
spectraPath2 = which( localSpectra2 );

% Load local spectra
Data1 = load( spectraPath1 );
if matches( localSpectra1, localSpectra2 )
    Data2 = Data1;
else
    Data2 = load( spectraPath2 );
end

% Event-locked windowings
eventCentres = fieldnames( Data1 );
nCentres     = length( eventCentres );
if nCentres ~= length( fieldnames( Data2 ) )
    error( 'Number of event-locked windowings mismatch between local spectra files' )
end

% Conditions in the data
ConditionField1 = strrep( condition1, ' ', '' );
ConditionField2 = strrep( condition2, ' ', '' );
iCondition1     = matches( Data1.(eventCentres{1}).Conditions, ConditionField1 );
iCondition2     = matches( Data1.(eventCentres{1}).Conditions, ConditionField2 );
nConditions1    = sum( iCondition1 );
nConditions2    = sum( iCondition2 );

% Spectral metrics
spectralFields1  = fieldnames( Data1.(eventCentres{1}).GrandAverage );
spectralFields2  = fieldnames( Data2.(eventCentres{1}).GrandAverage );
metricFields     = ~contains( spectralFields1, { 'Unit' 'Dimension' } );
spectralMetrics  = spectralFields1(metricFields);
nSpectralMetrics = length( spectralMetrics );
if nSpectralMetrics ~= length( spectralFields2(~contains( spectralFields2, { 'Unit' 'Dimension' } )) )
    error( 'Spectral metrics mismatch between local spectra files' )
end

% Frequencies in the decomposition
frequencies = Data1.(eventCentres{1}).Frequencies;

% Sanity check
frequencySanity = Data1.(eventCentres{1}).Frequencies - Data2.(eventCentres{1}).Frequencies;
sanityEdge      = 1e-14;
frequencyInsane = any( frequencySanity > sanityEdge );
if frequencyInsane
    error( 'Frequencies mismatch between local spectra files' )
end

% Times in the decomposition
for w = 1:nCentres
    times.(eventCentres{w}) = Data1.(eventCentres{w}).Times;
end

% Sanity check
timeSanity = Data1.(eventCentres{1}).Times - Data2.(eventCentres{1}).Times;
sanityEdge = 1e-14;
timeInsane = any( timeSanity > sanityEdge );
if timeInsane
    error( 'Times mismatch between local spectra files' )
end

% Sampling rate
if  isfield( Data1.(eventCentres{1}), 'SamplingRate' ) && ...
    isfield( Data2.(eventCentres{1}), 'SamplingRate' ) && ...
   ~isempty( Data1.(eventCentres{1}).SamplingRate )    && ...
   ~isempty( Data2.(eventCentres{1}).SamplingRate )
    if Data1.(eventCentres{1}).SamplingRate == Data2.(eventCentres{1}).SamplingRate
        samplingRate = Data1.(eventCentres{1}).SamplingRate;
    else
        error( 'Sampling rate mismatch between local spectra files' )
    end
else
    samplingRate = 1000;
end


%% Testing limits
% -------------------------------------------------------------------------

% All frequencies
if isempty( frequencyBand )
    frequencyBand = [ frequencies(1) frequencies(end) ];
end

% Frequency band limits
[ frequencyBand, bandName ] = aprioriFrequencyBands( frequencyBand );

% Frequency band indices
% Index of the frequency closest to each frequency band limit
[ ~, iBand1 ]   = min( abs( frequencies - frequencyBand(1) ) );
[ ~, iBand2 ]   = min( abs( frequencies - frequencyBand(2) ) );

% Frequencies in the frequency band
iFrequencyBand  = iBand1:iBand2;
frequenciesBand = frequencies(iFrequencyBand);
nFrequencies    = length( frequenciesBand );

% Time limit non-zero scalar or vector of time limits
if ( isscalar( timeLimits ) && timeLimits ~= 0 ) || ...
   ( isvector( timeLimits ) && ~isempty( timeLimits ) )
    
    timeLimit = zeros( nCentres, 2 );

    try
        earliestTime = timeLimits(1);
        maximumTime  = timeLimits(2);
    catch
        earliestTime = 0; % Alternative: max( 0, 90 - timeLimits/40 );
        maximumTime  = timeLimits;
    end

    for w = 1:nCentres

        % Stimulus-related window
        if contains( eventCentres{w}, 'Stim', 'IgnoreCase', true )
            timeLimit(w,:) = [ earliestTime maximumTime ];

        % Initiation-related window
        elseif contains( eventCentres{w}, 'Init', 'IgnoreCase', true )
            timeLimit(w,:) = [ -maximumTime/2 maximumTime/2 ];

        % Response-related window
        elseif contains( eventCentres{w}, 'Resp', 'IgnoreCase', true )
            timeLimit(w,:) = [ -maximumTime/2 maximumTime/2 ];

        % General event-related window
        else
            timeLimit(w,:) = [ -maximumTime/2 maximumTime ];

        end

    end

% Matrix of time limits
elseif size( timeLimits, 1 ) == nCentres && size( timeLimits, 1 ) == 2
    timeLimit = timeLimits;

% Whole window
elseif ( isscalar( timeLimits ) && timeLimits == 0 ) || isempty( timeLimits )
    for w = 1:nCentres
        earliestTime   = times.(eventCentres{w})(1);
        maximumTime    = times.(eventCentres{w})(end);
        timeLimit(w,:) = [ earliestTime maximumTime ];                      %#ok
    end

% Error
else
    errorText = [ 'Input time limits (in ms) to test differences within as a ' ...
                  'scalar of the maximum time for stimulus-related spectra '   ...
                  'with other time limits dervied in proportion to it; a '     ...
                  '[t1 t2] vector of stimulus-related time limits with '       ...
                  'other time limits dervied in proportion to t2; or a '       ...
                  'w x t matrix of time limits (t) for each event-related '    ...
                  'window (w), semicolon-separated in alphabetical order, '    ...
                  'for example [t1Resp t2Resp; t1Stim t2Stim]; or 0 or []'     ...
                  'for the whole window' ];
    error( errorText )

end


%% Test oscillatory differences
% -------------------------------------------------------------------------

clusterRunTime( 'Spectral difference testing started at' )

% Loop through: Metrics and trial event-locked windows
for iMetric = 1:nSpectralMetrics
    for iEventWindow = 1:nCentres

        % Curent metric and event-locked window
        metric      = spectralMetrics{iMetric};
        eventWindow = eventCentres{iEventWindow};


        %% Time limits
        % -----------------------------------------------------------------

        % Current event-centred times
        times         = Data1.(eventWindow).Times;

        % Sanity check
        timeSanity    = Data1.(eventWindow).Times - Data2.(eventWindow).Times;
        sanityEdge    = 1e-14;
        timeInsane    = any( timeSanity > sanityEdge );
        if timeInsane
            error( 'Times mismatch between data 1 and data 2' )
        end
    
        % Current event-centred time limit indices
        [ ~, iTime1 ] = min( abs( times - timeLimit(iEventWindow,1) ) );
        [ ~, iTime2 ] = min( abs( times - timeLimit(iEventWindow,2) ) );

        % Current event-centred window times
        iTimesLimited = iTime1:iTime2;
        timesLimited  = times(iTimesLimited);
        nTimesLimited = length( timesLimited );


        %% Oscillatory data
        % -----------------------------------------------------------------

        % Spectra for all people
        % Participants x Conditions x Frequencies x Times
        oscillations1 = Data1.(eventWindow).(metric)(:,iCondition1,iFrequencyBand,iTimesLimited);
        oscillations2 = Data2.(eventWindow).(metric)(:,iCondition2,iFrequencyBand,iTimesLimited);
        if nConditions1 > 1
            oscillations1 = mean( oscillations1, 2, "omitnan" );
        end
        if nConditions2 > 1
            oscillations2 = mean( oscillations2, 2, "omitnan" );
        end
        oscillations1 = squeeze( oscillations1 );
        oscillations2 = squeeze( oscillations2 );

        % Spectra differences for all people
        oscillationsD = oscillations1 - oscillations2;

        % Grand average data
        grandAverage1 = Data1.(eventWindow).GrandAverage.(metric);
        grandAverage2 = Data2.(eventWindow).GrandAverage.(metric);
        if ismatrix( grandAverage1 )
            grandAverage1 = grandAverage1(iFrequencyBand,iTimesLimited);
            grandAverage2 = grandAverage2(iFrequencyBand,iTimesLimited);
        else
            grandAverage1 = grandAverage1(iCondition1,iFrequencyBand,iTimesLimited);
            grandAverage2 = grandAverage2(iCondition2,iFrequencyBand,iTimesLimited);
            if nConditions1 > 1
                grandAverage1 = mean( grandAverage1, 1, "omitnan" );
            end
            if nConditions2 > 1
                grandAverage2 = mean( grandAverage2, 1, "omitnan" );
            end
        end
        grandAverage1 = squeeze( grandAverage1 );
        grandAverage2 = squeeze( grandAverage2 );


        %% Spectral difference t-statistics
        % -----------------------------------------------------------------

        % Dependent samples t-statistics
        meanDifferences = mean( oscillationsD, 1, 'omitnan' );
        stdDifferences  = std( oscillationsD, 0, 1, 'omitnan' );
        N               = size( oscillationsD, 1 );
        tStats          = meanDifferences ./ ( stdDifferences / sqrt( N ) );
        tStats          = squeeze( tStats );

        % Cluster t-threshold
        df              = N - 1;
        tThreshold      = abs( tinv( pThreshold, df ) );

        % Masks
        maskPositive    = tStats >= tThreshold;
        maskNegative    = tStats <= -tThreshold;
        mask            = or( maskPositive, maskNegative );


        %% Plot spectral data

        % Title addendum
        if ~isempty( comparison3 )
            comparison3Title = [ newline comparison3 ];
        end

        % Colour limits
        minimumGA1   = min( grandAverage1, [], 'all', 'omitnan' );
        minimumGA2   = min( grandAverage2, [], 'all', 'omitnan' );
        minColour    = min( minimumGA1, minimumGA2 );
        maximumGA1   = max( grandAverage1, [], 'all', 'omitnan' );
        maximumGA2   = max( grandAverage2, [], 'all', 'omitnan' );
        maxColour    = max( maximumGA1, maximumGA2 );
        colourLimits = [ minColour maxColour ];

        % Plot grand average 1
        figGA1      = plotTimeFrequency( grandAverage1, frequenciesBand, timesLimited );
        figNameGA1  = [ eventWindow '-Related ' bandName ' ' metric newline 'of ' comparison1 comparison3Title ];
        title( figNameGA1 )
        colormap( jetzeroed( colourLimits ) )
        fileNameGA1 = [ eventWindow '-Related ' bandName ' ' metric ' of ' comparison1 comparison3 '.fig' ];
        savefig( figGA1, fileNameGA1 )

        % Plot grand average 2
        figGA2      = plotTimeFrequency( grandAverage2, frequenciesBand, timesLimited );
        figNameGA2  = [ eventWindow '-Related ' bandName ' ' metric newline 'of ' comparison2 comparison3Title ];
        title( figNameGA2 )
        colormap( jetzeroed( colourLimits ) )
        fileNameGA2 = [ eventWindow '-Related ' bandName ' ' metric ' of ' comparison2 comparison3 '.fig' ];
        savefig( figGA2, fileNameGA2 )

        % Plot masked differences
        maskedD   = squeeze( meanDifferences ) .* mask;
        figD      = plotTimeFrequency( maskedD, frequenciesBand, timesLimited );
        figNameD  = [ eventWindow '-Related ' bandName ' ' metric newline 'of ' comparison1 ' - ' comparison2 comparison3Title ];
        title( figNameD )
        colormap( jetzeroed() )
        fileNameD = [ eventWindow '-Related ' bandName ' ' metric ' of ' comparison1 ' - ' comparison2 comparison3 '.fig' ];
        savefig( figD, fileNameD )

        % Plot masked t-map
        maskedT   = tStats .* mask;
        figT      = plotTimeFrequency( maskedT, frequenciesBand, timesLimited );
        figNameT  = [ eventWindow '-Related ' bandName ' ' metric ' t-Statistics' newline 'of ' comparison1 ' vs ' comparison2 comparison3Title ];
        title( figNameT )
        colormap( jetzeroed() )
        fileNameT = [ eventWindow '-Related ' bandName ' ' metric ' t-Statistics of ' comparison1 ' vs ' comparison2 comparison3 '.fig' ];
        savefig( figT, fileNameT )


        %% Cluster permutation testing
        % -----------------------------------------------------------------

        % Downsampling
        if ~isempty( downsampling ) && isnumeric( downsampling ) && downsampling ~= samplingRate

            % Downsample with anti-aliasing using pop_resample from EEGLAB
            if exist( 'eeglab', 'file' )
                spectraD    = [];
                for p = 1:N
                    singleSpectra   = squeeze( oscillationsD(p,:,:) );
                    EEG             = eeg_emptyset();
                    EEG.data        = singleSpectra;
                    EEG.times       = timesLimited;
                    EEG.nbchan      = nFrequencies;
                    EEG.trials      = 1;
                    EEG.pnts        = nTimesLimited;
                    EEG.xmin        = 0;
                    EEG.xmax        = ( nTimesLimited - 1 ) / samplingRate;
                    EEG.srate       = samplingRate;
                    EEG             = eeg_checkset( EEG );
                    EEG             = pop_resample( EEG, downsampling );
                    spectraD(p,:,:) = EEG.data;                                 %#ok
                end
                testedTimes = EEG.times;
                timeShift   = samplingRate / downsampling;

            % Downsample without anti-aliasing
            else
                timeShift   = samplingRate / downsampling;
                dt          = round( timeShift );
                spectraD    = oscillationsD(:,:,1:dt:end);
                testedTimes = timesLimited(1:dt:end);

            end
            
        % No downsampling
        else
            spectraD    = oscillationsD;
            testedTimes = timesLimited;
            timeShift   = 0;

        end

        % Plot tested differences
        testedMeanD = squeeze( mean( spectraD, 1, 'omitnan' ) );
        fig         = plotTimeFrequency( testedMeanD, frequenciesBand, testedTimes );
        figName     = [ eventWindow '-Related ' bandName ' ' metric newline  ...
                        'of ' comparison1 ' - ' comparison2 comparison3Title ...
                        newline 'Tested Differences' ];
        title( figName )
        colormap( jetzeroed() )
        figFileName = [ eventWindow '-Related ' bandName ' ' metric      ...
                        ' of ' comparison1 ' - ' comparison2 comparison3 ...
                        ' Tested Differences.fig' ];
        savefig( fig, figFileName )

        % % Distance between each time-frequency point for clustering
        % clusterRunTime( 'Distance function' )
        % global distances
        % distances = spectralDistances( spectraD );

        clusterRunTime( 'Cluster permutation test' )

        % Collapse frequencies and times into one dimension for testing
        nTimes   = size( spectraD, 3 );
        spectraD = reshape( spectraD, N, nFrequencies * nTimes );
        spectraD = spectraD';

        % Permutation test
        [ p, s ] = montecluster( spectraD, nPermutations, 'tf', pThreshold, ...
                                 frequencies, [ nFrequencies nTimes ], 1, timeShift, 1 );

        % Store in struct
        if p(1) ~= 0
            Stats.(eventWindow).(metric).p     = p(1);
            Stats.(eventWindow).(metric).Sigma = s(1);
        else
            Stats.(eventWindow).(metric).p     = [ '< ' num2str( 1/nPermutations ) ];
            Stats.(eventWindow).(metric).Sigma = [ '> ' num2str( abs( norminv( 1/nPermutations ) ) ) ];
        end
        if p(1) == p(2) && ~isnan( p(1) )
            direction = 'Positive difference';
        elseif p(1) == p(3) && ~isnan( p(1) )
            direction = 'Negative difference';
        elseif isnan( p(1) )
            direction = 'No cluster';
        end
        Stats.(eventWindow).(metric).Direction = direction;
        if p(2) ~= 0
            Stats.(eventWindow).(metric).Positive.p     = p(2);
            Stats.(eventWindow).(metric).Positive.Sigma = s(2);
        else
            Stats.(eventWindow).(metric).Positive.p     = [ '<' num2str( 1/nPermutations ) ];
            Stats.(eventWindow).(metric).Positive.Sigma = [ '>' num2str( abs( norminv( 1/nPermutations ) ) ) ];
        end
        if p(3) ~= 0
            Stats.(eventWindow).(metric).Negative.p     = p(3);
            Stats.(eventWindow).(metric).Negative.Sigma = s(3);
        else
            Stats.(eventWindow).(metric).Negative.p     = [ '<' num2str( 1/nPermutations ) ];
            Stats.(eventWindow).(metric).Negative.Sigma = [ '>' num2str( abs( norminv( 1/nPermutations ) ) ) ];
        end


        %% Descriptive statistics
        % -----------------------------------------------------------------

        % Comparison field names
        Comparison1Field = comparison1;
        Comparison1Field = strrep( Comparison1Field, ' ', '' );
        Comparison1Field = strrep( Comparison1Field, '-', '' );
        Comparison1Field = strrep( Comparison1Field, '.', '' );
        if isnumeric( Comparison1Field(1) )
            Comparison1Field = [ 'D' Comparison1Field ];                    %#ok
        end
        Comparison2Field = comparison2;
        Comparison2Field = strrep( Comparison2Field, ' ', '' );
        Comparison2Field = strrep( Comparison2Field, '-', '' );
        Comparison2Field = strrep( Comparison2Field, '.', '' );
        if isnumeric( Comparison2Field(1) )
            Comparison2Field = [ 'D' Comparison2Field ];                    %#ok
        end

        % Distributions across people of event-related spectral dispersion
        % (inter-quartile range, L-scale, and root mean squared deviation
        % from the signed root mean squared) for the paired comparison
        distribution1     = reshape( oscillations1, N, nFrequencies * nTimesLimited );
        distribution2     = reshape( oscillations2, N, nFrequencies * nTimesLimited );
        distributionIQR1  = iqr( distribution1, 2 );
        distributionIQR2  = iqr( distribution2, 2 );
        if any( distributionIQR1 == 0, 'all' )
            iConstant = find( distributionIQR1 == 0 );
            error( [ 'Constant values in group A for person ' num2str( iConstant ) ' in ' eventWindow '-related ' metric ] )
        end
        if any( distributionIQR2 == 0, 'all' )
            iConstant = find( distributionIQR2 == 0 );
            error( [ 'Constant values in group B for person ' num2str( iConstant ) ' in ' eventWindow '-related ' metric ] )
        end
        Stats.(eventWindow).(metric).Stats.([ Comparison1Field 'IQR' ]) = descriptiveStatistics( distributionIQR1 );
        Stats.(eventWindow).(metric).Stats.([ Comparison2Field 'IQR' ]) = descriptiveStatistics( distributionIQR2 );
        distributionLscale1 = lscale( distribution1, 2 );
        distributionLscale2 = lscale( distribution2, 2 );
        Stats.(eventWindow).(metric).Stats.([ Comparison1Field 'Lscale' ]) = descriptiveStatistics( distributionLscale1 );
        Stats.(eventWindow).(metric).Stats.([ Comparison2Field 'Lscale' ]) = descriptiveStatistics( distributionLscale2 );
        distributionRMSD1 = rmsdrms( distribution1, 2 );
        distributionRMSD2 = rmsdrms( distribution2, 2 );
        Stats.(eventWindow).(metric).Stats.([ Comparison1Field 'RMSDeviation' ]) = descriptiveStatistics( distributionRMSD1 );
        Stats.(eventWindow).(metric).Stats.([ Comparison2Field 'RMSDeviation' ]) = descriptiveStatistics( distributionRMSD2 );

        % Plot distributions of event-related spectral dispersion

        % Dispersion limits
        metricUnits = Data1.(eventWindow).([ metric 'Units' ]);
        maxRange    = max( range( oscillations1, 'all' ), range( oscillations2, 'all' ) );
        limits      = [0 maxRange];

        % Event-related spectral IQR
        figIQR = plotDistributions( distributionIQR1, distributionIQR2, ...
                                    metricUnits, comparison1, comparison2, limits );
        xl     = xlim;
        xl(1)  = max( xl(1), 0 );
        xlim( xl )
        distributionsIQRName = [ eventWindow '-Related ' bandName newline ...
                                 'Distribution of ' metric ' Dispersion (IQR)' ];
        title( distributionsIQRName )
        distributionsIQRFile = [ eventWindow '-Related ' bandName             ...
                                 'Distribution of ' metric ' Dispersion IQR ' ...
                                 'for ' comparison1 ' vs ' comparison2        ...
                                 comparison3 '.fig'                           ];
        savefig( figIQR, distributionsIQRFile )

        % Event-related spectral L-scale
        figLS = plotDistributions( distributionLscale1, distributionLscale2, ...
                                   metricUnits, comparison1, comparison2, limits );
        xl     = xlim;
        xl(1)  = max( xl(1), 0 );
        xlim( xl )
        distributionsLSName = [ eventWindow '-Related ' bandName newline ...
                                'Distribution of ' metric ' Dispersion (L-Scale)' ];
        title( distributionsLSName )
        distributionsLSFile = [ eventWindow '-Related ' bandName                 ...
                                'Distribution of ' metric ' Dispersion L-Scale ' ...
                                'for ' comparison1 ' vs ' comparison2            ...
                                comparison3 '.fig'                               ];
        savefig( figLS, distributionsLSFile )

        % Event-related spectral RMS deviation from the signed RMS
        figRMS = plotDistributions( distributionRMSD1, distributionRMSD2, ...
                                    metricUnits, comparison1, comparison2, limits );
        xl     = xlim;
        xl(1)  = max( xl(1), 0 );
        xlim( xl )
        distributionsRMSName = [ eventWindow '-Related ' bandName newline      ...
                                 'Distribution of ' metric ' Dispersion '      ...
                                 newline '(RMS Deviation from the Signed RMS)' ];
        title( distributionsRMSName )
        distributionsRMSFile = [ eventWindow '-Related ' bandName                  ...
                                 'Distribution of ' metric ' Dispersion RMS '      ...
                                 'Deviation from the Signed RMS for '              ...
                                 comparison1 ' vs ' comparison2 comparison3 '.fig' ];
        savefig( figRMS, distributionsRMSFile )

        % Clusters extrema data
        maskPositiveN = zeros( N, nFrequencies, nTimesLimited );
        maskNegativeN = zeros( N, nFrequencies, nTimesLimited );
        maskN         = zeros( N, nFrequencies, nTimesLimited );
        for pn = 1:N
            maskPositiveN(pn,:,:) = maskPositive;
            maskNegativeN(pn,:,:) = maskNegative;
            maskN(pn,:,:)         = mask;
        end
        if p(1) == p(2) && ~isnan( p(1) )                                   % ~isnan( p(2) ) && ( p(2) < p(3) || isnan( p(3) ) )
            data1Values = oscillations1 .* maskPositiveN;
            data2Values = oscillations2 .* maskPositiveN;
        elseif p(1) == p(3) && ~isnan( p(1) )                               % ~isnan( p(3) ) && ( p(3) < p(2) || ~isnan( p(2) ) )
            data1Values = oscillations1 .* maskNegativeN;
            data2Values = oscillations2 .* maskNegativeN;
        elseif isnan( p(1) )                                                % ( isnan( p(2) ) && isnan( p(3) ) )
            data1Values = oscillations1 .* NaN;
            data2Values = oscillations2 .* NaN;
        else
            data1Values = oscillations1 .* maskN;
            data2Values = oscillations2 .* maskN;
        end
        data1Values(data1Values == 0) = NaN;
        data2Values(data2Values == 0) = NaN;

        % Distributions across people of event-related spectral clusters
        % (medians) for the paired comparison
        distributionC1 = reshape( data1Values, N, nFrequencies * nTimesLimited );
        distributionC2 = reshape( data2Values, N, nFrequencies * nTimesLimited );
        distributionC1 = median( distributionC1, 2, 'omitnan' );
        distributionC2 = median( distributionC2, 2, 'omitnan' );
        Stats.(eventWindow).(metric).Stats.([ Comparison1Field 'Clusters' ]) ...
            = descriptiveStatistics( distributionC1 );
        Stats.(eventWindow).(metric).Stats.([ Comparison2Field 'Clusters' ]) ...
            = descriptiveStatistics( distributionC2 );

        % Plot clusters distributions
        if contains( metric, 'coherence', 'IgnoreCase', true )
            limits = [0 1];
        else
            limits = 'unbounded';
        end
        figC = plotDistributions( distributionC1, distributionC2, ...
                                  metricUnits, comparison1, comparison2, limits );
        clustersName = [ eventWindow '-Related ' bandName newline ...
                         'Distribution of ' metric ' Clusters'    ];
        title( clustersName )
        if contains( metric, 'coherence', 'IgnoreCase', true )
            xl  = xlim;
            xl1 = max( xl(1), 0 );
            xl2 = min( xl(2), 1 );
            xlim( [xl1 xl2] )
        end
        clustersFile = [ eventWindow '-Related ' bandName ' Distribution of ' metric ...
                         ' Clusters for ' comparison1 ' vs ' comparison2 comparison3 '.fig' ];
        savefig( figC, clustersFile )


    end % for iEventWindows
end % for iMetrics


% Comparison information
Stats.Comparison.Data1                   = [ comparison1 comparison3 ];
Stats.Comparison.Data2                   = [ comparison2 comparison3 ];
Stats.Comparison.N                       = N;
Stats.Comparison.DifferenceType          = 'Paired data from repeated measures of a single sample';
Stats.Comparison.FrequencyBand           = frequencyBand;
Stats.Comparison.TimeLimits              = timeLimit;
if ~isempty( downsampling ) && isnumeric( downsampling ) && downsampling ~= samplingRate
    Stats.Comparison.SamplingRate        = downsampling;
else
    Stats.Comparison.SamplingRate        = samplingRate;
end
Stats.Comparison.ClusterStatistic        = 'Maximum cluster sum of dependent samples t-statistics';
Stats.Comparison.ClusterThreshold.pValue = pThreshold;
Stats.Comparison.ClusterThreshold.tValue = tThreshold;
Stats.Comparison.Permutations            = nPermutations;


% Save spectral difference statistics
save SpectralDifferenceStatistics Stats

clusterRunTime( 'Spectral difference testing completed at' )


% _________________________________________________________________________
end



%%
% •.° EEGLAB Initialisation
% _________________________________________________________________________
%
function eegStartup

% Check if EEGLAB is being used
eeglabVariableUsage   = ( exist( 'EEG',    'var' ) && ~isempty( EEG )    && ~isempty( EEG.data ) )       || ...
                        ( exist( 'ALLEEG', 'var' ) && ~isempty( ALLEEG ) && ~isempty( ALLEEG(1).data ) ) || ...
                        ( exist( 'STUDY',  'var' ) && ~isempty( STUDY ) );
erplabVariableUsage   =   exist( 'ALLERP', 'var' ) && ~isempty( ALLERP );
existenceCommand      = "exist( 'globalvars', 'var' ) || exist( 'tmpEEG', 'var' )";
baseVariableExistence = evalin( "base", existenceCommand );

% Initialise EEGLAB
eeglab nogui

% Clear global variables unless they are being used
if ~eeglabVariableUsage
    clearvars -global ALLCOM ALLEEG CURRENTSET CURRENTSTUDY EEG LASTCOM PLUGINLIST STUDY
end
if ~erplabVariableUsage
    clearvars -global ALLERP
end

% Clear variables set in the Base Workspace unless they are being used
if ~baseVariableExistence
    evalin( "base", "clearvars globalvars tmpEEG" )
end


% _________________________________________________________________________
end



%% 
% •.° Frequency Band Definitions °.•
% _________________________________________________________________________
%
function [ frequencyLimits, bandName ] = aprioriFrequencyBands( frequencyBand )

% Frequency band names
delta      = { 'Delta' 'D' };
theta      = { 'Theta' 'T' };
alpha      = { 'Alpha' 'A' };
beta       = { 'Beta'  'B' };
gamma      = { 'Gamma' 'G' };
lowGamma   = { 'Low Gamma'  'LowGamma'  'Gamma1' 'G1' };
highGamma  = { 'High Gamma' 'HighGamma' 'Gamma2' 'G2' };

% Organisation for Human Brain Mapping definitions (Pernet et al., 2018)
deltaBand  = [ 1       3.999  ];
thetaBand  = [ 4       7.999  ];
alphaBand  = [ 8       12.999 ];
betaBand   = [ 13      30     ];
gammaBand  = [ 30.001  80     ];

% Gamma-band divisions
gammaBand1 = [ 30.001  50     ];
gammaBand2 = [ 50.001  80     ];

% Extended theta+ peak finding window
thetaX     = { 'Theta+'  'T+'  'Tp'    'ThetaPlus'  'ThetaExtended'  'Tx' };
thetaXF    = [ 2.5 8.5 ];

% 2-10 Hz theta++ peak finding window (Gyurkovics & Levita, 2021) 
thetaX2    = { 'Theta++' 'T++' 'Tpp'   'ThetaPlus2' 'ThetaPlusPlus' ...
               'ThetaGyurkovicsLevita' 'ThetaGL'    'TGL'           };
thetaX2F   = [ 2 10 ];

% Frequency limits
if ischar( frequencyBand )
    switch lower( frequencyBand )
        case lower( delta )
            frequencyLimits = deltaBand;
            bandName        = delta{1};
        case lower( theta )
            frequencyLimits = thetaBand;
            bandName        = theta{1};
        case lower( alpha )
            frequencyLimits = alphaBand;
            bandName        = alpha{1};
        case lower( beta )
            frequencyLimits = betaBand;
            bandName        = beta{1};
        case lower( gamma )
            frequencyLimits = gammaBand;
            bandName        = gamma{1};
        case lower( lowGamma )
            frequencyLimits = gammaBand1;
            bandName        = lowGamma{2};
        case lower( highGamma )
            frequencyLimits = gammaBand2;
            bandName        = highGamma{2};
        case lower( thetaX )
            frequencyLimits = thetaXF;
            bandName        = thetaX{1};
        case lower( thetaX2 )
            frequencyLimits = thetaX2F;
            bandName        = thetaX2{1};
    end
elseif isnumeric( frequencyBand )
            frequencyLimits = frequencyBand;
            bandName        = [ num2str( frequencyBand(1) ) 'Hz-' num2str( frequencyBand(2) ) 'Hz' ];
else
    error( 'Specify a named frequency band or frequency limits in Hz as [f1 f2]' )
end

% • References •
% -------------------------------------------------------------------------
%
% Gyurkovics, M. & Levita, L. (2021). Dynamic Adjustments of Midfrontal
%  Control Signals in Adults and Adolescents. Cerebral Cortex, 31(2),
%  795–808. https://doi.org/10.1093/cercor/bhaa258
%
% Pernet, C. R., Garrido, M., Gramfort, A., Maurits, N., Michel, C., Pang,
%  E., … Puce, A. (2018, August 9). Best Practices in Data Analysis and
%  Sharing in Neuroimaging using MEEG. https://doi.org/10.31219/osf.io/a8dhx


% _________________________________________________________________________
end


%%
% •.° Sample L-Scale °.•
% _________________________________________________________________________
%
function ls = lscale( X )

% Number of people
N = size( X, 1 );

% Number of metric cluster space points
m = size( X, 2 );

% Order statistics of X
Xi = sort( X, 2 );

% L-scale constant
constant = 1 / ( 2 * nchoosek( m, 2 ) );

% L-scale binomial coefficients
BC.Lxi = zeros( N, m ); % Less than xi
BC.Rxi = zeros( N, m ); % Greater than xi
for p = 1:N
    for i = 1:m
        if i - 1 >= 2
            BC.Lxi(p,i) = i - 1;
        end
        if m - i >= 2
            BC.Rxi(p,i) = m - i;
        end
    end
end

% L-scale terms
terms = ( BC.Lxi - BC.Rxi ) .* Xi;

% L-scale
ls = constant * sum( terms );

% • Reference •
% -------------------------------------------------------------------------
%
% Wang, Q. J. (1996). Direct sample estimators of L moments. Water 
%  Resources Research, 32(12), 3617-3619. https://doi.org/10.1029/96WR02675


% _________________________________________________________________________
end



%%
% •.° Root Mean Squared Deviation From The Root Mean Squared °.•
% _________________________________________________________________________
%
function rmsd = rmsdrms( X, dim )

% Sign of the mean
signX = sign( mean( X, dim, 'omitnan') );

% Root mean squared
rmsX  = rms( X, dim, 'omitnan' );

% Signed root mean squared
srms  = rmsX .* signX;

% Deviation from the signed root mean squared
drms  = X - srms;

% Root mean squared deviation from the root mean squared
rmsd  = rms( drms, dim, 'omitnan' );


% _________________________________________________________________________
end



%%
% •.° Plot Distributions °.•
% _________________________________________________________________________
%
function fig = plotDistributions( data1, data2, metricUnits, comparison1, comparison2, limits )

fig = figure;

% Raincloud plots (Allen et al., 2021)
if ( exist( 'raincloud_plot_k.m', 'file' ) || exist( 'raincloud_plot.m', 'file' ) ) ...
   && ~all( isnan( data1 ), 'all' ) && ~all( isnan( data2 ), 'all' )

    colour1 = [ 1  0  0 ];
    colour2 = [ 0 0.3 1 ];

    % Modified raincloud plot function with kernel support limits
    if exist( 'raincloud_plot_k.m', 'file' )

        distribution2 = raincloud_plot_k( data2(:),                    ...
                                          'color',            colour2, ...
                                          'alpha',            0.3,     ...
                                          'cloud_edge_col',   colour2, ...
                                          'box_on',           1,       ...
                                          'box_col_match',    1,       ...
                                          'box_dodge',        1,       ...
                                          'box_dodge_amount', .35,     ...
                                          'dot_dodge_amount', .35,     ...
                                          'support',          limits   );

        distribution1 = raincloud_plot_k( data1(:),                    ...
                                          'color',            colour1, ...
                                          'alpha',            0.3,     ...
                                          'cloud_edge_col',   colour1, ...
                                          'box_on',           1,       ...
                                          'box_col_match',    1,       ...
                                          'box_dodge',        1,       ...
                                          'box_dodge_amount', .15,     ...
                                          'dot_dodge_amount', .15,     ...
                                          'support',          limits   );

    % Original raincloud plot function
    else

        distribution2 = raincloud_plot(   data2(:),                    ...
                                          'color',            colour2, ...
                                          'alpha',            0.3,     ...
                                          'cloud_edge_col',   colour2, ...
                                          'box_on',           1,       ...
                                          'box_col_match',    1,       ...
                                          'box_dodge',        1,       ...
                                          'box_dodge_amount', .35,     ...
                                          'dot_dodge_amount', .35      );

        distribution1 = raincloud_plot(   data1(:),                    ...
                                          'color',            colour1, ...
                                          'alpha',            0.3,     ...
                                          'cloud_edge_col',   colour1, ...
                                          'box_on',           1,       ...
                                          'box_col_match',    1,       ...
                                          'box_dodge',        1,       ...
                                          'box_dodge_amount', .15,     ...
                                          'dot_dodge_amount', .15      );

    end

    legend( [ distribution1{1} distribution2{1} ], { comparison1 comparison2 } );
    ylabel( 'Probability Density' )
    xlabel( metricUnits )

    maxDensity1 = max( distribution1{1}.YData );
    maxDensity2 = max( distribution2{1}.YData );
    maxDensity  = max( maxDensity1, maxDensity2 );
    ylim( [ -0.6*maxDensity 1.05*maxDensity ] )

% Box plots
else
    boxplot( [ data1(:) data2(:) ], 'labels', { comparison1 comparison2 } )
    ylabel( metricUnits )

end

set( gcf, 'Color', 'w' )

% • Reference •
% -------------------------------------------------------------------------
%
% Allen, M., Poggiali, D., Whitaker, K., Marshall, T. R., van Langen, J., &
%   Kievit, R. A. (2021). Raincloud plots: a multi-platform tool for robust
%   data visualization [version 2; peer review: 2 approved]. Wellcome open
%   research, 4, 63. https://doi.org/10.12688/wellcomeopenres.15191.2


% _________________________________________________________________________
end



%%
% •.° Cluster Run Time °.•
% _________________________________________________________________________
%
function clusterRunTime( message )

% Time
theTimeIs = datetime( 'now' );
theTimeIs = char( theTimeIs );

% Print
if exist( 'message', 'var' )
    disp( [ message ' ' theTimeIs ] )
else
    disp( theTimeIs )
end
disp( ' ' )


% _________________________________________________________________________
end



%% 
% % •.° Spectra Distance Function °.•
% % _________________________________________________________________________
% %
% function distances = spectralDistances( spectra )
% 
% % Dimensions
% nFrequencies = size( spectra, 2 );
% nTimes       = size( spectra, 3 );
% nFxT         = nFrequencies * nTimes;
% 
% % Pre-allocate
% distances = zeros( nFxT );
% 
% % Cluster adjacency threshold
% adjacency = ceil( sqrt( 2 ) * 10 ) / 10;
% 
% % Build FxT indices
% indices = cell( 1, nFxT );
% counter = 0;
% for iT = 1:nTimes
%     for iF = 1:nFrequencies
%         counter = counter + 1;
% 
%         indices{counter} = [iF iT];
% 
%     end
% end
% 
% % Frequency x time distances
% for i = 1:nFxT
%     for j = i+1:nFxT
% 
%         Fi = indices{i}(1);
%         Fj = indices{j}(1);
%         Ti = indices{i}(2);
%         Tj = indices{j}(2);
% 
%         % Euclidean distance
%         distances(i,j) = sqrt( ( Fi - Fj )^2 + ( Ti - Tj )^2 );
% 
%         distances(j,i) = distances(i,j);
% 
%     end
% end
% 
% % Normalisation
% distances = distances ./ adjacency;
% 
% 
% % ______________________________________________________________________
% end


