function Stats = spectralClusters( pThreshold, frequencyBand, timeLimits, downsampling )
%
% •.° Differential Oscillatory Clusters °.•
% _________________________________________________________________________
%
% !!! THIS IS A WORK IN PROGRESS !!!
%
% Test oscillatory differences in neural event-related spectra
%
% Localised event-related spectral data collated by eegLocalSpectra.m
% from time-frequency decompositions generated by eegTimeFrequency.m or
% equivalent (King, 2023) available at https://github.com/neuroro/EEG/
%
% • Usage •
% ------------------------------------------------------------------------- 
% Set the Current Folder to the location of the localised event-related 
% spectra file TimeFrequency<Cluster>.mat
% 
% >> spectralClusters( pThreshold, frequencyBand, timeLimits, downsampling )
% 
% For example:
% >> spectralClusters
% >> spectralClusters( 0.025, 'theta+', [75 600], 250 )
%
% .. . .  .   .     .        .             .                     .                                  .
%
% •••( Function Inputs )
%
%   pThreshold:    Threshold as a p-value from which the equivalent
%                   |t|-value at the degrees of freedom of the data is
%                   used to form clusters of spectral differences
%                  (optional input: default 0.025)
%
%   frequencyBand: Frequency band (named) or frequency range (limits)
%                   within which to test differences
%                    'Delta'        1 to <4 Hz
%                    'Theta'        4 to <8 Hz
%                    'Theta+'     2.5 to 8.5 Hz
%                    'Theta++'      2 to 10 Hz
%                    'Alpha'        8 to <13 Hz
%                    'Beta'        13 to 30 Hz
%                    'Gamma'      >30 to 80 Hz
%                    'Low Gamma'  >30 to 50 Hz
%                    'High Gamma' >50 to 80 Hz
%                    [f1 f2]      f1 to f2 Hz frequency range
%                   (optional input: default theta extended to 2.5-8.5 Hz)
%
%   timeLimits:    Time limits (in ms) to test differences within as a
%                   scalar of the maximum time for stimulus-related spectra
%                    with other time limits dervied in proportion to it; a
%                   [t1 t2] vector of stimulus-related time limits with
%                    other time limits dervied in proportion to t2; or a
%                   w x t matrix of time limits (t) for each event-related
%                    window (w), semicolon-separated in alphbetical order, 
%                    for example [t1Resp t2Resp; t1Stim t2Stim]
%                   (optional input: default 75-600 ms after the stimulus, 
%                    and -third to +half the maximum around the response)
%
%   downsampling:   Sampling rate (in Hz) to downsample the data to using
%                    pop-resample from EEGLAB for anti-aliasing, which may
%                    be used to speed up the computation time, in case 2-D
%                    cluster permutation testing takes too long
%                   (optional input: default 250 Hz)
%
% .. . .  .   .     .        .             .                     .                                  .
%
% [ Function Outputs ] =
%
%   Cluster permutation test statistics and descriptive statistics of
%    event-related spectra distributions and plots of grand average
%    spectra, difference spectra, and their t-maps
%
% !!! Requires !!!
%
%   descriptiveStatsitics.m by Rohan King (2023) available at
%    https://github.com/neuroro/EEG/descriptiveStatsitics.m
%   EEGLAB
%
% • Author •
% -------------------------------------------------------------------------
% Rohan O. C. King, 2023
%
% GitHub @neuroro
%
% Copyright 2023 Rohan King
%
% This program is free software: you can redistribute it and/or modify it
% under the terms of the GNU General Public License as published by the
% Free Software Foundation, either version 3 of the License, or (at your
% option) any later version.
%
% This program is distributed in the hope that it will be useful, but
% WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General
% Public License for more details (https://www.gnu.org/licenses/).
%
% Please cite this code if you use it
%
% King, R. (2023). spectralClusters [MATLAB code]. GitHub. 
% https://github.com/neuroro/EEG/spectralClusters.m


%% Configuration
% -------------------------------------------------------------------------

% Local spectra mat files
LOCALSPECTRA1 = 'TimeFrequencyFMClusterAcuteJuice.mat';
LOCALSPECTRA2 = 'TimeFrequencyClusterAcutePlacebo.mat';

% Conditions
CONDITION1    = 'Acute Juice';
CONDITION2    = 'Acute Placebo';

% Metrics and trial event-locked windows
METRICS       = { 'SpectralPower' 'PhaseCoherence' };
WINDOWS       = { 'Stimulus'      'Response'       };


%% Default inputs
% -------------------------------------------------------------------------

% Cluster p-value threshold
if ~nargin
    pThreshold = 0.025;
end

% Frequency band
if ~exist( 'frequencyBand', 'var' ) || nargin < 2
    frequencyBand = 'Theta+';
end
if isstring( frequencyBand )
    frequencyBand = char( frequencyBand );
end

% Time limit
if ~exist( 'timeLimits', 'var' ) || ( isscalar( timeLimits ) && ~timeLimits )
    timeLimits = 600;
end

% Downsampling to speed up computation
if ~exist( 'downsampling', 'var' ) || nargin < 4
    downsampling = 250;
end


%% Decomposition properties
% -------------------------------------------------------------------------

% Local spectra mat file paths
spectraPath1    = which( LOCALSPECTRA1 );
spectraPath2    = which( LOCALSPECTRA2 );

% Load local spectra
Data1           = load( spectraPath1 );
Data2           = load( spectraPath2 );

ConditionField1 = strrep( CONDITION1, ' ', '' );
ConditionField2 = strrep( CONDITION2, ' ', '' );
iCondition1     = 1;
iCondition2     = 1;
nCentres        = 2;

% Frequencies in the decomposition
frequencies     = Data1.(WINDOWS{1}).Frequencies;

% Sanity check
frequencySanity = Data1.(WINDOWS{1}).Frequencies - Data2.(WINDOWS{1}).Frequencies;
sanityEdge      = 1e-14;
frequencyInsane = any( frequencySanity > sanityEdge );
if frequencyInsane
    error( 'Frequencies mismatch between data 1 and data 2' )
end

% Sampling rate
if  isfield( Data1.(WINDOWS{1}), 'SamplingRate' ) && ...
    isfield( Data2.(WINDOWS{1}), 'SamplingRate' ) && ...
   ~isempty( Data1.(WINDOWS{1}).SamplingRate )    && ...
   ~isempty( Data2.(WINDOWS{1}).SamplingRate )
    if Data1.(WINDOWS{1}).SamplingRate == Data2.(WINDOWS{1}).SamplingRate
        samplingRate = Data1.(WINDOWS{1}).SamplingRate;
    else
        error( 'Sampling rate mismatch between data 1 and data 2' )
    end
else
    samplingRate = 1000;
end


%% Testing limits
% -------------------------------------------------------------------------

% All frequencies
if isempty( frequencyBand )
    frequencyBand = [ frequencies(1) frequencies(end) ];
end

% Frequency band limits
[ frequencyBand, bandName ] = aprioriFrequencyBands( frequencyBand );

% Frequency band indices
% Index of the frequency closest to each frequency band limit
[ ~, iBand1 ]   = min( abs( frequencies - frequencyBand(1) ) );
[ ~, iBand2 ]   = min( abs( frequencies - frequencyBand(2) ) );

% Frequencies in the frequency band
iFrequencyBand  = iBand1:iBand2;
frequenciesBand = frequencies(iFrequencyBand);
nFrequencies    = length( frequenciesBand );

% Time limit scalar or vector of time limits
if isscalar( timeLimits ) || isvector( timeLimits )
    
    timeLimit = zeros( nCentres, 2 );

    try
        earliestTime = timeLimits(1);
        maximumTime  = timeLimits(2);
    catch
        earliestTime = max( 0, 90 - timeLimits/40 );
        maximumTime  = timeLimits;
    end

    for w = 1:nCentres

        % Stimulus-related window
        if contains( WINDOWS{w}, 'Stim', 'IgnoreCase', true )
            timeLimit(w,:) = [ earliestTime maximumTime ];

        % Initiation-related window
        elseif contains( WINDOWS{w}, 'Init', 'IgnoreCase', true )
            timeLimit(w,:) = [ -maximumTime/2 maximumTime/3 ];

        % Response-related window
        elseif contains( WINDOWS{w}, 'Resp', 'IgnoreCase', true )
            timeLimit(w,:) = [ -maximumTime/3 maximumTime/2 ];

        % General event-related window
        else
            timeLimit(w,:) = [ -maximumTime/2 maximumTime ];

        end

    end

% Matrix of time limits
elseif size( timeLimits, 1 ) == nCentres && size( timeLimits, 1 ) == 2
    timeLimit = timeLimits;

% Error
else
    errorText = [ 'Input time limits (in ms) to test differences within as a ' ...
                  'scalar of the maximum time for stimulus-related spectra '   ...
                  'with other time limits dervied in proportion to it; a '     ...
                  '[t1 t2] vector of stimulus-related time limits with '       ...
                  'other time limits dervied in proportion to t2; or a '       ...
                  'w x t matrix of time limits (t) for each event-related '    ...
                  'window (w), semicolon-separated in alphbetical order, '     ...
                  'for example [t1Resp t2Resp; t1Stim t2Stim]'                 ];
    error( errorText )

end


%% Test oscillatory differences
% -------------------------------------------------------------------------

% Loop through: Metrics and trial event-locked windows
for iMetric = 1:2
    for iEventWindow = 1:2

        % Curent metric and event-locked window
        metric          = METRICS{iMetric};
        eventWindow     = WINDOWS{iEventWindow};


        %% Time limits
        % -----------------------------------------------------------------

        % Current event-centred times
        times         = Data1.(eventWindow).Times;

        % Sanity check
        timeSanity    = Data1.(eventWindow).Times - Data2.(eventWindow).Times;
        sanityEdge    = 1e-14;
        timeInsane    = any( timeSanity > sanityEdge );
        if timeInsane
            error( 'Times mismatch between data 1 and data 2' )
        end
    
        % Current event-centred time limit indices
        [ ~, iTime1 ] = min( abs( times - timeLimit(iEventWindow,1) ) );
        [ ~, iTime2 ] = min( abs( times - timeLimit(iEventWindow,2) ) );

        % Current event-centred window times
        iTimesLimited = iTime1:iTime2;
        timesLimited  = times(iTimesLimited);
        nTimesLimited = length( timesLimited );


        %% Oscillatory data
        % -----------------------------------------------------------------

        % Spectra for all people
        oscillations1 = squeeze( Data1.(eventWindow).(metric)(:,iCondition1,iFrequencyBand,iTimesLimited) );
        oscillations2 = squeeze( Data2.(eventWindow).(metric)(:,iCondition2,iFrequencyBand,iTimesLimited) );

        % Spectra differences for all people
        oscillationsD = oscillations1 - oscillations2;

        % Grand average data
        grandAverage1 = Data1.(eventWindow).GrandAverage.(metric);
        grandAverage2 = Data2.(eventWindow).GrandAverage.(metric);
        if ismatrix( grandAverage1 )
            grandAverage1 = grandAverage1(iFrequencyBand,iTimesLimited);
            grandAverage2 = grandAverage2(iFrequencyBand,iTimesLimited);
        else
            grandAverage1 = squeeze( grandAverage1(iCondition1,iFrequencyBand,iTimesLimited) );
            grandAverage2 = squeeze( grandAverage2(iCondition1,iFrequencyBand,iTimesLimited) );
        end


        %% Difference statistics
        % -----------------------------------------------------------------

        % Dependent samples t-statistics
        meanDifferences = mean( oscillationsD, 1, 'omitnan' );
        stdDifferences  = std( oscillationsD, 0, 1, 'omitnan' );
        N               = size( oscillationsD, 1 );
        tStats          = meanDifferences ./ ( stdDifferences / sqrt( N ) );
        tStats          = squeeze( tStats );

        % Cluster t-threshold
        df              = N - 1;
        tThreshold      = abs( tinv( pThreshold, df ) );

        % Masks
        maskPositive    = tStats >= tThreshold;
        maskNegative    = tStats <= -tThreshold;
        mask            = or( maskPositive, maskNegative );

        % Downsample using pop_resample for anti-aliasing
%         spectraD        = NaN( N, nFrequencies, nTimesLimited );
        spectraD        = [];
        if ~isempty( downsampling ) && downsampling && downsampling ~= samplingRate
            for p = 1:N
                singleSpectra   = squeeze( oscillationsD(p,:,:) );
                EEG             = eeg_emptyset();
                EEG.data        = singleSpectra;
                EEG.nbchan      = nFrequencies;
                EEG.trials      = 1;
                EEG.pnts        = nTimesLimited;
                EEG.xmin        = 0;
                EEG.xmax        = ( nTimesLimited - 1 ) / samplingRate;
                EEG.srate       = samplingRate;
                EEG             = eeg_checkset( EEG );
                EEG             = pop_resample( EEG, downsampling );
                spectraD(p,:,:) = EEG.data;                                 %#ok
            end
        else
            spectraD    = oscillationsD;
        end

        % Distance between each time-frequency point for clustering
        global distances
        distances       = spectralDistances( spectraD );

        % Collapse frequencies and times into one dimension for testing
        nTimes          = size( spectraD, 3 );
        spectraD        = reshape( spectraD, N, nFrequencies * nTimes );
        spectraD        = spectraD';

        % Cluster permutation test
        [ p, s ]        = montecluster( spectraD, 1e4, pThreshold, 3, frequencies, [ nFrequencies nTimes ], 1, 1, 1 );

        % Store in struct
        Stats.(eventWindow).(metric).p = p;
        Stats.(eventWindow).(metric).s = s;


        %% Descriptive statistics
        % -----------------------------------------------------------------

        % Tested distributions
        Stats.(eventWindow).(metric).Stats.(ConditionField1) = descriptiveStatistics( oscillations1(:) );
        Stats.(eventWindow).(metric).Stats.(ConditionField2) = descriptiveStatistics( oscillations2(:) );

        % Extrema distributions
        % Overall maximum and direction
        if ~isnan( p(2) ) && ( p(2) < p(3) || isnan( p(3) ) )
            data1Values = grandAverage1 .* maskPositive;
            data2Values = grandAverage2 .* maskPositive;
        elseif ~isnan( p(3) ) && ( p(3) < p(2) || ~isnan( p(2) ) )
            data1Values = grandAverage1 .* maskNegative;
            data2Values = grandAverage2 .* maskNegative;
        elseif isnan( p(2) ) && isnan( p(3) )
            data1Values = grandAverage1 .* NaN;
            data2Values = grandAverage2 .* NaN;
        else
            data1Values = grandAverage1 .* mask;
            data2Values = grandAverage2 .* mask;
        end
        data1Values(data1Values == 0) = NaN;
        data2Values(data2Values == 0) = NaN;
        Stats.(eventWindow).(metric).Stats.([ ConditionField1 'Extrema' ]) = descriptiveStatistics( data1Values(:) );
        Stats.(eventWindow).(metric).Stats.([ ConditionField2 'Extrema' ]) = descriptiveStatistics( data2Values(:) );


        %% Plot data

        % Plot grand average 1
        plotTimeFrequency( grandAverage1, frequenciesBand, timesLimited )
        figName = [ eventWindow '-Related ' bandName ' ' metric ' Under ' CONDITION1 ];
        title( figName )
        colormap( JuiceZeroed() )
        savefig( figName )

        % Plot grand average 2
        plotTimeFrequency( grandAverage2, frequenciesBand, timesLimited )
        figName = [ eventWindow '-Related ' bandName ' ' metric ' Under ' CONDITION2 ];
        title( figName )
        colormap( JuiceZeroed() )
        savefig( figName )

        % Plot masked differences
        maskedD = squeeze( meanDifferences ) .* mask;
        plotTimeFrequency( maskedD, frequenciesBand, timesLimited )
        figName = [ eventWindow '-Related ' bandName ' ' metric ' ' CONDITION1 ' - ' CONDITION2 ' Differences' ];
        title( figName )
        colormap( JuiceZeroed() )
        savefig( figName )

        % Plot masked t-map
        maskedT = tStats .* mask;
        plotTimeFrequency( maskedT, frequenciesBand, timesLimited )
        figName = [ 'T-Map of ' eventWindow '-Related ' bandName ' ' metric ' ' CONDITION1 ' - ' CONDITION2 ' Differences' ];
        title( figName )
        colormap( JuiceZeroed() )
        savefig( figName )

        % !!! PLOT DISTRIBUTIONS AS VIOLINS !!!

        % !!! EXPORT DATA TO MODEL IN R & PLOT WITH GGPLOT2 !!!


    end % for iEventWindows
end % for iMetrics


% _________________________________________________________________________
end



%% 
% •.° Spectra Distance Function °.•
% _________________________________________________________________________
%
function distances = spectralDistances( spectra )

% Dimensions
nFrequencies = size( spectra, 2 );
nTimes       = size( spectra, 3 );
nFxT         = nFrequencies * nTimes;

% Pre-allocate
distances = zeros( nFxT );

% Cluster adjacency threshold
adjacency = ceil( sqrt( 2 ) * 10 ) / 10;

% Build FxT indices
indices = cell( 1, nFxT );
counter = 0;
for iF = 1:nFrequencies
    for iT = 1:nTimes
        counter = counter + 1;

        indices{counter} = [iF iT];

    end
end

% Frequency x time distances
for i = 1:nFxT
    for j = i+1:nFxT

        FxTi = indices{i};
        FxTj = indices{j};

        % Pythagorean distance
        distances(i,j) = sqrt( (FxTi(1) - FxTj(1))^2 ...
                             + (FxTi(2) - FxTj(2))^2 );

        distances(j,i) = distances(i,j);

    end
end

% Normalisation
distances = distances ./ adjacency;


% ______________________________________________________________________
end



%% 
% •.° Frequency Band Definitions °.•
% _________________________________________________________________________
%
function [ frequencyLimits, bandName ] = aprioriFrequencyBands( frequencyBand )

% Frequency band names
delta      = { 'Delta' 'D' };
theta      = { 'Theta' 'T' };
alpha      = { 'Alpha' 'A' };
beta       = { 'Beta'  'B' };
gamma      = { 'Gamma' 'G' };
lowGamma   = { 'Low Gamma'  'LowGamma'  'Gamma1' 'G1' };
highGamma  = { 'High Gamma' 'HighGamma' 'Gamma2' 'G2' };

% Organisation for Human Brain Mapping definitions (Pernet et al., 2018)
deltaBand  = [ 1       3.999  ];
thetaBand  = [ 4       7.999  ];
alphaBand  = [ 8       12.999 ];
betaBand   = [ 13      30     ];
gammaBand  = [ 30.001  80     ];

% Gamma-band divisions
gammaBand1 = [ 30.001  50     ];
gammaBand2 = [ 50.001  80     ];

% Extended theta+ peak finding window
thetaX     = { 'Theta+'  'T+'  'Tp'    'ThetaPlus'  'ThetaExtended'  'Tx' };
thetaXF    = [ 2.5 8.5 ];

% 2-10 Hz theta++ peak finding window (Gyurkovics & Levita, 2021) 
thetaX2    = { 'Theta++' 'T++' 'Tpp'   'ThetaPlus2' 'ThetaPlusPlus' ...
               'ThetaGyurkovicsLevita' 'ThetaGL'    'TGL'           };
thetaX2F   = [ 2 10 ];

% Frequency limits
if ischar( frequencyBand )
    switch lower( frequencyBand )
        case lower( delta )
            frequencyLimits = deltaBand;
            bandName        = delta{1};
        case lower( theta )
            frequencyLimits = thetaBand;
            bandName        = theta{1};
        case lower( alpha )
            frequencyLimits = alphaBand;
            bandName        = alpha{1};
        case lower( beta )
            frequencyLimits = betaBand;
            bandName        = beta{1};
        case lower( gamma )
            frequencyLimits = gammaBand;
            bandName        = gamma{1};
        case lower( lowGamma )
            frequencyLimits = gammaBand1;
            bandName        = lowGamma{2};
        case lower( highGamma )
            frequencyLimits = gammaBand2;
            bandName        = highGamma{2};
        case lower( thetaX )
            frequencyLimits = thetaXF;
            bandName        = thetaX{1};
        case lower( thetaX2 )
            frequencyLimits = thetaX2F;
            bandName        = thetaX2{1};
    end
elseif isnumeric( frequencyBand )
            frequencyLimits = frequencyBand;
            bandName        = [ num2str( frequencyBand(1) ) 'Hz-' num2str( frequencyBand(2) ) 'Hz' ];
else
    error( 'Specify a named frequency band or frequency limits in Hz as [f1 f2]' )
end

% • References •
% -------------------------------------------------------------------------
%
% Gyurkovics, M. & Levita, L. (2021). Dynamic Adjustments of Midfrontal
%   Control Signals in Adults and Adolescents. Cerebral Cortex, 31(2), 
%   795–808. https://doi.org/10.1093/cercor/bhaa258
%
% Pernet, C. R., Garrido, M., Gramfort, A., Maurits, N., Michel, C., Pang,
%   E., … Puce, A. (2018, August 9). Best Practices in Data Analysis and
%   Sharing in Neuroimaging using MEEG.
%   https://doi.org/10.31219/osf.io/a8dhx


% _________________________________________________________________________
end


